(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{427:function(e,t,r){"use strict";r.r(t);var a=r(21),v=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"内存分配"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内存分配"}},[e._v("#")]),e._v(" 内存分配")]),e._v(" "),r("p",[e._v("程序中的数据和变量都会被分配到程序所在的虚拟内存中，内存空间包含两个重要区域：栈区（Stack）和堆区（Heap）。函数调用的参数、返回值以及局部变量大都会被分配到栈上，这部分内存会由编译器进行管理；其他的比如对象则由内存分配器分配并由垃圾收集器回收。")]),e._v(" "),r("h3",{attrs:{id:"基本概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[e._v("#")]),e._v(" 基本概念")]),e._v(" "),r("h4",{attrs:{id:"内存管理由三部分组成"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内存管理由三部分组成"}},[e._v("#")]),e._v(" 内存管理由三部分组成")]),e._v(" "),r("ol",[r("li",[e._v("用户程序（Mutator）")]),e._v(" "),r("li",[e._v("分配器（Allocator）")]),e._v(" "),r("li",[e._v("收集器（Collector）")])]),e._v(" "),r("p",[e._v("当 "),r("strong",[e._v("用户程序申请内存")]),e._v(" 时，它会通过 "),r("strong",[e._v("内存分配器申请新内存")]),e._v(" ，而分配器会负责从堆中初始化相应的内存区域。收集器就负责回收垃圾")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://img.xiaoyou66.com/2021/03/26/8d1550bb488f5.png",alt:"mutator-allocator-collector"}})]),e._v(" "),r("h4",{attrs:{id:"分配的方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分配的方法"}},[e._v("#")]),e._v(" 分配的方法")]),e._v(" "),r("p",[e._v("内存分配主要分为下面两种方法")]),e._v(" "),r("ul",[r("li",[r("p",[r("strong",[e._v("线性分配器（Sequential Allocator，Bump Allocator）")]),e._v(" 维护一大块内存，需要的时候就从这块内存中去分配，实现比较简单，但是已经分配的内存无法重新利用（需要配合垃圾回收算法使用）")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://img.xiaoyou66.com/2021/03/26/537664307a682.png",alt:"bump-allocator-reclaim-memory"}})])]),e._v(" "),r("li",[r("p",[r("strong",[e._v("空闲链表分配器（Free-List Allocator）")]),e._v(" 这个可以重用已经释放过的内存，内部会维护一个链表的结构，申请内存时会依次遍历空闲的内存块，找到足够大的内存，然后申请新的资源并修改链表")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://img.xiaoyou66.com/2021/03/26/25e674a1a13b0.png",alt:"free-list-allocator"}})])])]),e._v(" "),r("p",[e._v("链表分配器有四种分配策略")]),e._v(" "),r("ul",[r("li",[e._v("首次适应（First-Fit）— 从链表头开始遍历，选择第一个大小大于申请内存的内存块；")]),e._v(" "),r("li",[e._v("循环首次适应（Next-Fit）— 从上次遍历的结束位置开始遍历，选择第一个大小大于申请内存的内存块；")]),e._v(" "),r("li",[e._v("最优适应（Best-Fit）— 从链表头遍历整个链表，选择最合适的内存块；")]),e._v(" "),r("li",[e._v("隔离适应（Segregated-Fit）— 将内存分割成多个链表，每个链表中的内存块大小相同，申请内存时先找到满足条件的链表，再从链表中选择合适的内存块")])]),e._v(" "),r("p",[r("strong",[e._v("go使用的是类似于隔离适应的策略，下图是这个策略的简单介绍")])]),e._v(" "),r("p",[r("img",{attrs:{src:"https://img.xiaoyou66.com/2021/03/26/4a9671966347a.png",alt:"segregated-list"}})]),e._v(" "),r("h4",{attrs:{id:"如何分配"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何分配"}},[e._v("#")]),e._v(" 如何分配")]),e._v(" "),r("p",[e._v("上面说了一下内存分配的方法，下面简单介绍一下内存是如何分配的，go借鉴线程缓存分配（Thread-Caching Malloc，TCMalloc）的方法来进行内存分配，它的核心理念是使用多级缓存将对象根据大小分类，并按照类别实施不同的分配策略。")]),e._v(" "),r("p",[e._v("Go 语言的内存分配器会根据 "),r("strong",[e._v("申请分配的内存大小选择不同的处理逻辑")]),e._v(" ，运行时根据对象的大小将对象分成微对象、小对象和大对象三种（因为程序中的绝大多数对象的大小都在 32KB 以下，而申请的内存大小影响 Go 语言运行时分配内存的过程和开销，所以分别处理大对象和小对象有利于提高内存分配器的性能。）")]),e._v(" "),r("table",[r("thead",[r("tr",[r("th",{staticStyle:{"text-align":"center"}},[e._v("类别")]),e._v(" "),r("th",{staticStyle:{"text-align":"center"}},[e._v("大小")])])]),e._v(" "),r("tbody",[r("tr",[r("td",{staticStyle:{"text-align":"center"}},[e._v("微对象")]),e._v(" "),r("td",{staticStyle:{"text-align":"center"}},[r("code",[e._v("(0, 16B)")])])]),e._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[e._v("小对象")]),e._v(" "),r("td",{staticStyle:{"text-align":"center"}},[r("code",[e._v("[16B, 32KB]")])])]),e._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[e._v("大对象")]),e._v(" "),r("td",{staticStyle:{"text-align":"center"}},[r("code",[e._v("(32KB, +∞)")])])])])]),e._v(" "),r("p",[e._v("内存分配器不仅会区别对待大小不同的对象，还会 "),r("strong",[e._v("将内存分成不同的级别分别管理")]),e._v(" ，TCMalloc 和 Go 运行时分配器都会引入线程缓存（Thread Cache）、中心缓存（Central Cache）和页堆（Page Heap）三个组件分级管理内存，示意图如下")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://img.xiaoyou66.com/2021/03/26/493eaff280ff8.png",alt:"multi-level-cache"}})]),e._v(" "),r("p",[e._v("线程缓存属于每一个独立的线程，它能够满足线程上绝大多数的内存分配需求，因为不涉及多线程，所以也不需要使用互斥锁来保护内存，这能够减少锁竞争带来的性能损耗。当线程缓存不能满足需求时，运行时会使用中心缓存作为补充解决小对象的内存分配，在遇到 32KB 以上的对象时，内存分配器会选择页堆直接分配大内存。")]),e._v(" "),r("h4",{attrs:{id:"虚拟内存布局"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#虚拟内存布局"}},[e._v("#")]),e._v(" 虚拟内存布局")]),e._v(" "),r("p",[e._v("前面说了分配的方法和如何分配，下面说一下go的堆区内存是如何布局的")]),e._v(" "),r("p",[e._v("go1.10之前使用的是线性内存，虽然简单且方便，但是c和go混用的时候会导致程序奔溃。所以下面要讲的是Go的1.11提出的稀疏内存。")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://img.xiaoyou66.com/2021/03/26/1528335631758.png",alt:"heap-after-go-1-11"}})]),e._v(" "),r("p",[e._v("使用稀疏的内存布局不仅能移除堆大小的上限"),r("a",{attrs:{href:"https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/#fn:5",target:"_blank",rel:"noopener noreferrer"}},[e._v("5"),r("OutboundLink")],1),e._v("，还能解决 C 和 Go 混合使用时的地址空间冲突问题"),r("a",{attrs:{href:"https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/#fn:6",target:"_blank",rel:"noopener noreferrer"}},[e._v("6"),r("OutboundLink")],1),e._v("。不过因为基于稀疏内存的内存管理失去了内存的连续性这一假设，这也使内存管理变得更加复杂，由于内存的管理变得更加复杂，上述改动对垃圾回收稍有影响，大约会增加 1% 的垃圾回收开销，不过这也是我们为了解决已有问题必须付出的成本"),r("a",{attrs:{href:"https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/#fn:7",target:"_blank",rel:"noopener noreferrer"}},[e._v("7"),r("OutboundLink")],1),e._v("。")]),e._v(" "),r("h4",{attrs:{id:"地址空间"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#地址空间"}},[e._v("#")]),e._v(" 地址空间")]),e._v(" "),r("p",[e._v("因为所有的内存最终都是要从操作系统中申请的，所以 Go 语言的运行时构建了操作系统的内存管理抽象层，该抽象层将运行时管理的地址空间分成以下四种状态"),r("a",{attrs:{href:"https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/#fn:8",target:"_blank",rel:"noopener noreferrer"}},[e._v("8"),r("OutboundLink")],1),e._v("：")]),e._v(" "),r("table",[r("thead",[r("tr",[r("th",{staticStyle:{"text-align":"center"}},[e._v("状态")]),e._v(" "),r("th",{staticStyle:{"text-align":"center"}},[e._v("解释")])])]),e._v(" "),r("tbody",[r("tr",[r("td",{staticStyle:{"text-align":"center"}},[r("code",[e._v("None")])]),e._v(" "),r("td",{staticStyle:{"text-align":"center"}},[e._v("内存没有被保留或者映射，是地址空间的默认状态")])]),e._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[r("code",[e._v("Reserved")])]),e._v(" "),r("td",{staticStyle:{"text-align":"center"}},[e._v("运行时持有该地址空间，但是访问该内存会导致错误")])]),e._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[r("code",[e._v("Prepared")])]),e._v(" "),r("td",{staticStyle:{"text-align":"center"}},[e._v("内存被保留，一般没有对应的物理内存访问该片内存的行为是未定义的可以快速转换到 "),r("code",[e._v("Ready")]),e._v(" 状态")])]),e._v(" "),r("tr",[r("td",{staticStyle:{"text-align":"center"}},[r("code",[e._v("Ready")])]),e._v(" "),r("td",{staticStyle:{"text-align":"center"}},[e._v("可以被安全访问")])])])]),e._v(" "),r("h3",{attrs:{id:"内存管理组件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内存管理组件"}},[e._v("#")]),e._v(" 内存管理组件")]),e._v(" "),r("p",[e._v("前面说了一些基本概念，这里就总结一下整个GO的内存分配器结构")]),e._v(" "),r("p",[e._v("Go 语言的内存分配器包含内存管理单元、线程缓存、中心缓存和页堆几个重要组件，整个结构图如下")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://img.xiaoyou66.com/2021/03/26/48b092c6c5205.png",alt:"go-memory-layout"}})]),e._v(" "),r("p",[e._v("所有的 Go 语言程序都会在启动时初始化如上图所示的内存布局，每一个处理器都会分配一个线程缓存 "),r("a",{attrs:{href:"https://draveness.me/golang/tree/runtime.mcache",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("runtime.mcache")]),r("OutboundLink")],1),e._v(" 用于处理微对象和小对象的分配，它们会持有内存管理单元 "),r("a",{attrs:{href:"https://draveness.me/golang/tree/runtime.mspan",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("runtime.mspan")]),r("OutboundLink")],1),e._v("。")]),e._v(" "),r("p",[e._v("每个类型的内存管理单元都会管理特定大小的对象，当内存管理单元中不存在空闲对象时，它们会从 "),r("a",{attrs:{href:"https://draveness.me/golang/tree/runtime.mheap",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("runtime.mheap")]),r("OutboundLink")],1),e._v(" 持有的 134 个中心缓存 "),r("a",{attrs:{href:"https://draveness.me/golang/tree/runtime.mcentral",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("runtime.mcentral")]),r("OutboundLink")],1),e._v(" 中获取新的内存单元，中心缓存属于全局的堆结构体 "),r("a",{attrs:{href:"https://draveness.me/golang/tree/runtime.mheap",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("runtime.mheap")]),r("OutboundLink")],1),e._v("，它会从操作系统中申请内存。")]),e._v(" "),r("p",[e._v("在 amd64 的 Linux 操作系统上，"),r("a",{attrs:{href:"https://draveness.me/golang/tree/runtime.mheap",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("runtime.mheap")]),r("OutboundLink")],1),e._v(" 会持有 4,194,304 "),r("a",{attrs:{href:"https://draveness.me/golang/tree/runtime.heapArena",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("runtime.heapArena")]),r("OutboundLink")],1),e._v("，每个 "),r("a",{attrs:{href:"https://draveness.me/golang/tree/runtime.heapArena",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("runtime.heapArena")]),r("OutboundLink")],1),e._v(" 都会管理 64MB 的内存，单个 Go 语言程序的内存上限也就是 256TB。")]),e._v(" "),r("h2",{attrs:{id:"垃圾收集"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集"}},[e._v("#")]),e._v(" 垃圾收集")]),e._v(" "),r("h3",{attrs:{id:"基本概念-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基本概念-2"}},[e._v("#")]),e._v(" 基本概念")]),e._v(" "),r("p",[e._v("在开始介绍之前需要先一些基本的概念，方便对后面的内容进行理解")]),e._v(" "),r("h4",{attrs:{id:"标记清除"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#标记清除"}},[e._v("#")]),e._v(" 标记清除")]),e._v(" "),r("p",[e._v("标记清除（Mark-Sweep）算法是最常见的垃圾收集算法，标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段。")]),e._v(" "),r("h4",{attrs:{id:"三色抽象"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#三色抽象"}},[e._v("#")]),e._v(" 三色抽象")]),e._v(" "),r("p",[e._v("为了解决原始标记清除算法带来的长时间 STW，多数现代的追踪式垃圾收集器都会实现三色标记算法的变种以 "),r("strong",[e._v("缩短 STW 的时间")]),e._v("  三色标记算法将程序中的对象分成白色、黑色和灰色三类：")]),e._v(" "),r("ul",[r("li",[e._v("白色对象 — 潜在的垃圾，其内存可能会被垃圾收集器回收；")]),e._v(" "),r("li",[e._v("黑色对象 — 活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象；")]),e._v(" "),r("li",[e._v("灰色对象 — 活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象；")])]),e._v(" "),r("p",[r("img",{attrs:{src:"https://img.xiaoyou66.com/2021/03/26/d76b9df6cb7b4.png",alt:"tri-color-objects"}})]),e._v(" "),r("p",[e._v("三色标记垃圾收集器的工作原理很简单，我们可以将其归纳成以下几个步骤：")]),e._v(" "),r("ol",[r("li",[e._v("从灰色对象的集合中选择一个灰色对象并将其标记成黑色；")]),e._v(" "),r("li",[e._v("将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收；")]),e._v(" "),r("li",[e._v("重复上述两个步骤直到对象图中不存在灰色对象；")])]),e._v(" "),r("p",[e._v("当标记结束后，应用程序就不存在任何的灰色对象，这个时候，垃圾收集器就会回收白色垃圾。")]),e._v(" "),r("p",[e._v("使用三色标记时，为了避免用户程序修改对象指针，所以我们需要STW，如果想并发或者增量来标记对象时，我们需要使用屏障技术")]),e._v(" "),r("h4",{attrs:{id:"屏障技术"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#屏障技术"}},[e._v("#")]),e._v(" 屏障技术")]),e._v(" "),r("p",[e._v("内存屏障技术是一种屏障指令，它可以让 CPU 或者编译器在执行内存相关操作时遵循特定的约束，目前多数的现代处理器都会乱序执行指令以最大化性能，但是该技术能够保证内存操作的顺序性，在内存屏障前执行的操作一定会先于内存屏障后执行的操作"),r("a",{attrs:{href:"https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#fn:6",target:"_blank",rel:"noopener noreferrer"}},[e._v("6"),r("OutboundLink")],1),e._v("。")]),e._v(" "),r("p",[e._v("要想在并发标记时确保正确性，我们就必须要达成下面两种三色不变性中的一种：")]),e._v(" "),r("ul",[r("li",[e._v("强三色不变性 — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；")]),e._v(" "),r("li",[e._v("弱三色不变性 — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径")])]),e._v(" "),r("p",[e._v("下图展示了这两种三色不变性：")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://img.xiaoyou66.com/2021/03/26/613cef16020e6.png",alt:"strong-weak-tricolor-invariant"}})]),e._v(" "),r("p",[e._v("怎么保证三色不变性呢？答案是使用屏障技术")]),e._v(" "),r("p",[e._v("垃圾收集中的屏障技术更像是一个钩子方法，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，根据操作类型的不同，我们可以将它们分成读屏障（Read barrier）和写屏障（Write barrier）两种，因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，"),r("strong",[e._v("所以编程语言往往都会采用写屏障保证三色不变性。")])]),e._v(" "),r("p",[e._v("Go 语言中使用的两种写屏障技术，分别是 Dijkstra 提出的插入写屏障"),r("a",{attrs:{href:"https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#fn:8",target:"_blank",rel:"noopener noreferrer"}},[e._v("8"),r("OutboundLink")],1),e._v("和 Yuasa 提出的删除写屏障"),r("a",{attrs:{href:"https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#fn:9",target:"_blank",rel:"noopener noreferrer"}},[e._v("9"),r("OutboundLink")],1),e._v("。")]),e._v(" "),r("p",[e._v("具体过程就不细表，可以参考："),r("a",{attrs:{href:"https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#%E6%8F%92%E5%85%A5%E5%86%99%E5%B1%8F%E9%9A%9C",target:"_blank",rel:"noopener noreferrer"}},[e._v("Go 语言垃圾收集器的实现原理 | Go 语言设计与实现 (draveness.me)"),r("OutboundLink")],1)]),e._v(" "),r("h4",{attrs:{id:"增量和并发"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#增量和并发"}},[e._v("#")]),e._v(" 增量和并发")]),e._v(" "),r("p",[e._v("传统的垃圾收集算法会在垃圾收集的执行期间暂停应用程序，一旦触发垃圾收集，垃圾收集器会抢占 CPU 的使用权占据大量的计算资源以完成标记和清除工作，然而很多追求实时的应用程序无法接受长时间的 STW，而现在我们计算机往往是多核的，所以我们可以使用下面两种策略来优化我们的垃圾回收器：")]),e._v(" "),r("ul",[r("li",[e._v("增量垃圾收集 — 增量地标记和清除垃圾，降低应用程序暂停的最长时间；（把原本较长的暂停时间切分为多个更小的时间片）")]),e._v(" "),r("li",[e._v("并发垃圾收集 — 利用多核的计算资源，在用户程序执行时并发标记和清除垃圾；（收集器直接和程序一起运行，但是部分阶段也需要暂停程序）")])]),e._v(" "),r("p",[e._v("因为增量和并发两种方式都可以与用户程序交替运行，所以我们需要"),r("strong",[e._v("使用屏障技术")]),e._v("保证垃圾收集的正确性；与此同时，增量和并发的垃圾收集需要提前触发并在内存不足前完成整个循环，避免程序的长时间暂停。")]),e._v(" "),r("p",[e._v("演进过程，这部分内容比较多，所以就不展开讲了，直接跳到最新的垃圾回收器")]),e._v(" "),r("h3",{attrs:{id:"实现原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#实现原理"}},[e._v("#")]),e._v(" 实现原理")]),e._v(" "),r("ol",[r("li",[e._v("清理终止阶段；\n"),r("ol",[r("li",[r("strong",[e._v("暂停程序")]),e._v("，所有的处理器在这时会进入安全点（Safe point）；")]),e._v(" "),r("li",[e._v("如果当前垃圾收集循环是强制触发的，我们还需要处理还未被清理的内存管理单元；")])])]),e._v(" "),r("li",[e._v("标记阶段；\n"),r("ol",[r("li",[e._v("将状态切换至 "),r("code",[e._v("_GCmark")]),e._v("、开启写屏障、用户程序协助（Mutator Assiste）并将根对象入队；")]),e._v(" "),r("li",[e._v("恢复执行程序，标记进程和用于协助的用户程序会开始并发标记内存中的对象，写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新创建的对象都会被直接标记成黑色；")]),e._v(" "),r("li",[e._v("开始扫描根对象，包括所有 Goroutine 的栈、全局对象以及不在堆中的运行时数据结构，扫描 Goroutine 栈期间会暂停当前处理器；")]),e._v(" "),r("li",[e._v("依次处理灰色队列中的对象，将对象标记成黑色并将它们指向的对象标记成灰色；")]),e._v(" "),r("li",[e._v("使用分布式的终止算法检查剩余的工作，发现标记阶段完成后进入标记终止阶段；")])])]),e._v(" "),r("li",[e._v("标记终止阶段；\n"),r("ol",[r("li",[r("strong",[e._v("暂停程序")]),e._v("、将状态切换至 "),r("code",[e._v("_GCmarktermination")]),e._v(" 并关闭辅助标记的用户程序；")]),e._v(" "),r("li",[e._v("清理处理器上的线程缓存；")])])]),e._v(" "),r("li",[e._v("清理阶段；\n"),r("ol",[r("li",[e._v("将状态切换至 "),r("code",[e._v("_GCoff")]),e._v(" 开始清理阶段，初始化清理状态并关闭写屏障；")]),e._v(" "),r("li",[e._v("恢复用户程序，所有新创建的对象会标记成白色；")]),e._v(" "),r("li",[e._v("后台并发清理所有的内存管理单元，当 Goroutine 申请新的内存管理单元时就会触发清理；")])])])]),e._v(" "),r("h4",{attrs:{id:"触发时机"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#触发时机"}},[e._v("#")]),e._v(" 触发时机")]),e._v(" "),r("ul",[r("li",[r("p",[r("strong",[e._v("后台触发")]),e._v(" 运行时会在应用程序启动时在后台开启一个用于强制触发垃圾收集的 Goroutine，该 Goroutine 的职责非常简单 — 调用 "),r("a",{attrs:{href:"https://draveness.me/golang/tree/runtime.gcStart",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("runtime.gcStart")]),r("OutboundLink")],1),e._v(" 尝试启动新一轮的垃圾收集。（这个线程大部分是休眠状态，但是会被系统监视器在满足条件时唤醒）")])]),e._v(" "),r("li",[r("p",[r("strong",[e._v("手动触发")]),e._v("  用户程序会通过 "),r("a",{attrs:{href:"https://draveness.me/golang/tree/runtime.GC",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("runtime.GC")]),r("OutboundLink")],1),e._v(" 函数在程序运行期间主动通知运行时执行，该方法在调用时会阻塞调用方直到当前垃圾收集循环完成，在垃圾收集期间也可能会通过 STW 暂停整个程序")])]),e._v(" "),r("li",[r("p",[r("strong",[e._v("申请内存")]),e._v(" 申请内存时也可以触发垃圾回收")])])]),e._v(" "),r("h4",{attrs:{id:"内存清理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内存清理"}},[e._v("#")]),e._v(" 内存清理")]),e._v(" "),r("p",[e._v("垃圾收集的清理中包含对象回收器（Reclaimer）和内存单元回收器，这两种回收器使用不同的算法清理堆内存：")]),e._v(" "),r("ul",[r("li",[e._v("对象回收器在内存管理单元中查找并释放未被标记的对象，但是如果 "),r("a",{attrs:{href:"https://draveness.me/golang/tree/runtime.mspan",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("runtime.mspan")]),r("OutboundLink")],1),e._v(" 中的所有对象都没有被标记，整个单元就会被直接回收，该过程会被 "),r("a",{attrs:{href:"https://draveness.me/golang/tree/runtime.mcentral.cacheSpan",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("runtime.mcentral.cacheSpan")]),r("OutboundLink")],1),e._v(" 或者 "),r("a",{attrs:{href:"https://draveness.me/golang/tree/runtime.sweepone",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("runtime.sweepone")]),r("OutboundLink")],1),e._v(" 异步触发；")]),e._v(" "),r("li",[e._v("内存单元回收器会在内存中查找所有的对象都未被标记的 "),r("a",{attrs:{href:"https://draveness.me/golang/tree/runtime.mspan",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("runtime.mspan")]),r("OutboundLink")],1),e._v("，该过程会被 "),r("a",{attrs:{href:"https://draveness.me/golang/tree/runtime.mheap.reclaim",target:"_blank",rel:"noopener noreferrer"}},[r("code",[e._v("runtime.mheap.reclaim")]),r("OutboundLink")],1),e._v(" 触发；")])]),e._v(" "),r("h2",{attrs:{id:"栈内存管理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#栈内存管理"}},[e._v("#")]),e._v(" 栈内存管理")]),e._v(" "),r("p",[e._v("栈区的内存一般由编译器自动分配和释放，其中存储着函数的入参以及局部变量，这些参数会随着函数的创建而创建，函数的返回而消亡，一般不会在程序中长期存在，这种线性的内存分配策略有着极高地效率，但是工程师也往往不能控制栈内存的分配，这部分工作基本都是由编译器完成的。")]),e._v(" "),r("p",[e._v("Go语言的运行环境（runtime）会在goroutine需要的时候 "),r("strong",[e._v("动态地分配栈空间，而不是给每个goroutine分配固定大小的内存空间。")]),e._v(" 这样就避免了需要程序员来决定栈的大小。")]),e._v(" "),r("h3",{attrs:{id:"逃逸分析"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#逃逸分析"}},[e._v("#")]),e._v(" 逃逸分析")]),e._v(" "),r("p",[e._v("在编译器优化中，逃逸分析是用来决定指针动态作用域的方法"),r("a",{attrs:{href:"https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-stack-management/#fn:5",target:"_blank",rel:"noopener noreferrer"}},[e._v("5"),r("OutboundLink")],1),e._v("。Go 语言的编译器使用逃逸分析决定哪些变量应该在栈上分配，哪些变量应该在堆上分配，其中包括使用 "),r("code",[e._v("new")]),e._v("、"),r("code",[e._v("make")]),e._v(" 和字面量等方法隐式分配的内存，Go 语言的逃逸分析遵循以下两个不变性：")]),e._v(" "),r("ol",[r("li",[e._v("指向栈对象的指针不能存在于堆中；")]),e._v(" "),r("li",[e._v("指向栈对象的指针不能在栈对象回收后存活；")])]),e._v(" "),r("p",[e._v("在Go中逃逸分析是一种确定指针动态范围的方法，可以分析在程序的哪些地方可以访问到指针。它涉及到指针分析和形状分析。")]),e._v(" "),r("p",[e._v("当一个变量(或对象)在子程序中被分配时，一个指向变量的指针可能逃逸到其它执行线程中，或者去调用子程序。如果使用尾递归优化（通常在函数编程语言中是需要的），对象也可能逃逸到被调用的子程序中。 如果一个子程序分配一个对象并返回一个该对象的指针，该对象可能在程序中的任何一个地方被访问到——这样指针就成功“逃逸”了。")]),e._v(" "),r("p",[e._v("如果指针存储在全局变量或者其它数据结构中，它们也可能发生逃逸，这种情况是当前程序中的指针逃逸。 逃逸分析需要确定指针所有可以存储的地方，保证指针的生命周期只在当前进程或线程中。")]),e._v(" "),r("p",[e._v("导致内存逃逸的情况比较多，有些可能还是官方未能够实现精确的分析逃逸情况的 bug，通常来讲就是如果"),r("strong",[e._v("变量的作用域不会扩大并且其行为或者大小能够在编译的时候确定，一般情况下都是分配到栈上，否则就可能发生内存逃逸分配到堆上。")])]),e._v(" "),r("p",[e._v("内存逃逸的五种情况:")]),e._v(" "),r("ol",[r("li",[e._v("发送指针的指针或值包含了指针到"),r("code",[e._v("channel")]),e._v(" 中，由于在编译阶段无法确定其作用域与传递的路径，所以一般都会逃逸到堆上分配。")]),e._v(" "),r("li",[e._v("slices 中的值是指针的指针或包含指针字段。一个例子是类似"),r("code",[e._v("[]*string")]),e._v(" 的类型。这总是导致 slice 的逃逸。即使切片的底层存储数组仍可能位于堆栈上，数据的引用也会转移到堆中。")]),e._v(" "),r("li",[e._v("slice 由于 append 操作超出其容量，因此会导致 slice 重新分配。这种情况下，由于在编译时 slice 的初始大小的已知情况下，将会在栈上分配。如果 slice 的底层存储必须基于仅在运行时数据进行扩展，则它将分配在堆上。")]),e._v(" "),r("li",[e._v("调用接口类型的方法。接口类型的方法调用是动态调度,实际使用的具体实现只能在运行时确定。考虑一个接口类型为 io.Reader 的变量 r。对 r.Read(b) 的调用将导致 r 的值和字节片b的后续转义并因此分配到堆上。")]),e._v(" "),r("li",[e._v("尽管能够符合分配到栈的场景，但是其大小不能够在编译时候确定的情况，也会分配到堆上.")])]),e._v(" "),r("p",[e._v("有效的避免上述的五种逃逸的情况,就可以避免内存逃逸.")])])}),[],!1,null,null,null);t.default=v.exports}}]);