(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{438:function(t,e,r){"use strict";r.r(e);var n=r(21),o=Object(n.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("p",[t._v("这里主要涉及到IO多路复用")]),t._v(" "),r("h2",{attrs:{id:"基本概念介绍"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基本概念介绍"}},[t._v("#")]),t._v(" 基本概念介绍")]),t._v(" "),r("p",[r("strong",[t._v("BIO")]),t._v(" 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。")]),t._v(" "),r("p",[r("strong",[t._v("NIO")]),t._v(" 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。")]),t._v(" "),r("p",[r("strong",[t._v("AIO")]),t._v(" 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理.AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。")]),t._v(" "),r("h2",{attrs:{id:"netty"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#netty"}},[t._v("#")]),t._v(" Netty")]),t._v(" "),r("p",[t._v("Netty是 一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。Netty是基于nio的，它封装了jdk的nio，让我们使用起来更加方法灵活。")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://www.nowcoder.com/jump/super-jump/word?word=Netty",target:"_blank",rel:"noopener noreferrer"}},[t._v("Netty"),r("OutboundLink")],1),t._v("为什么没有用JDK自带的多路复用器（没答上来，提示JDK空轮训BUG）聊了聊"),r("a",{attrs:{href:"https://www.nowcoder.com/jump/super-jump/word?word=Netty",target:"_blank",rel:"noopener noreferrer"}},[t._v("Netty"),r("OutboundLink")],1),t._v("前身")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://blog.csdn.net/ThinkWon/article/details/104391081",target:"_blank",rel:"noopener noreferrer"}},[t._v("Netty面试题（2020最新版）_ThinkWon的博客-CSDN博客_netty面试题"),r("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=o.exports}}]);