(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{481:function(_,t,v){"use strict";v.r(t);var n=v(21),r=Object(n.a)({},(function(){var _=this,t=_.$createElement,v=_._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"spring事务传播"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#spring事务传播"}},[_._v("#")]),_._v(" spring事务传播")]),_._v(" "),v("p",[_._v("为什么要有事务传播呢？默认情况下，spring是使用aop来实现事务的，我们只需要在方法上面加上 "),v("code",[_._v("@Transactional")]),_._v(" 注解就可以了，但是这个时候会有几个问题比如 serviceA 方法调用了 serviceB 方法，但两个方法都有事务，这个时候如果 serviceB 方法异常，是让 serviceB 方法提交，还是两个一起回滚？")]),_._v(" "),v("p",[_._v("这里我们就要用到事务传播了，spring提供了7中事务传播行为（使用"),v("code",[_._v("@Transaction(Propagation=XXX)")]),_._v("设置决定）")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("事务传播行为类型")]),_._v(" "),v("th",[_._v("说明")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("PROPAGATION_REQUIRED")]),_._v(" "),v("td",[_._v("如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。")])]),_._v(" "),v("tr",[v("td",[_._v("PROPAGATION_SUPPORTS")]),_._v(" "),v("td",[_._v("支持当前事务，如果当前没有事务，就以非事务方式执行。")])]),_._v(" "),v("tr",[v("td",[_._v("PROPAGATION_MANDATORY")]),_._v(" "),v("td",[_._v("使用当前的事务，如果当前没有事务，就抛出异常。")])]),_._v(" "),v("tr",[v("td",[_._v("PROPAGATION_REQUIRES_NEW")]),_._v(" "),v("td",[_._v("新建事务，如果当前存在事务，把当前事务挂起。")])]),_._v(" "),v("tr",[v("td",[_._v("PROPAGATION_NOT_SUPPORTED")]),_._v(" "),v("td",[_._v("以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。")])]),_._v(" "),v("tr",[v("td",[_._v("PROPAGATION_NEVER")]),_._v(" "),v("td",[_._v("以非事务方式执行，如果当前存在事务，则抛出异常。")])]),_._v(" "),v("tr",[v("td",[_._v("PROPAGATION_NESTED")]),_._v(" "),v("td",[_._v("如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。")])])])]),_._v(" "),v("p",[_._v("还有spring本身不提供事务功能，事务功能是数据库提供的")]),_._v(" "),v("blockquote",[v("p",[_._v("参考")])]),_._v(" "),v("ol",[v("li",[v("a",{attrs:{href:"https://segmentfault.com/a/1190000020386113",target:"_blank",rel:"noopener noreferrer"}},[_._v("spring 事务的传播机制看这篇就够了 - SegmentFault 思否"),v("OutboundLink")],1)]),_._v(" "),v("li",[v("a",{attrs:{href:"https://segmentfault.com/a/1190000013341344",target:"_blank",rel:"noopener noreferrer"}},[_._v("Spring事务传播行为详解 - SegmentFault 思否"),v("OutboundLink")],1)])]),_._v(" "),v("h2",{attrs:{id:"事务隔离的五种级别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务隔离的五种级别"}},[_._v("#")]),_._v(" 事务隔离的五种级别")]),_._v(" "),v("p",[v("strong",[_._v("TransactionDefinition 接口中定义了五个表示隔离级别的常量：")])]),_._v(" "),v("ul",[v("li",[v("strong",[_._v("TransactionDefinition.ISOLATION_DEFAULT:")]),_._v(" 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.")]),_._v(" "),v("li",[v("strong",[_._v("TransactionDefinition.ISOLATION_READ_UNCOMMITTED:")]),_._v(" 最低的隔离级别，允许读取尚未提交的数据变更，"),v("strong",[_._v("可能会导致脏读、幻读或不可重复读")])]),_._v(" "),v("li",[v("strong",[_._v("TransactionDefinition.ISOLATION_READ_COMMITTED:")]),_._v(" 允许读取并发事务已经提交的数据，"),v("strong",[_._v("可以阻止脏读，但是幻读或不可重复读仍有可能发生")])]),_._v(" "),v("li",[v("strong",[_._v("TransactionDefinition.ISOLATION_REPEATABLE_READ:")]),_._v(" 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，"),v("strong",[_._v("可以阻止脏读和不可重复读，但幻读仍有可能发生。")])]),_._v(" "),v("li",[v("strong",[_._v("TransactionDefinition.ISOLATION_SERIALIZABLE:")]),_._v(" 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，"),v("strong",[_._v("该级别可以防止脏读、不可重复读以及幻读")]),_._v("。但是这将严重影响程序的性能。通常情况下也不会用到该级别。")])]),_._v(" "),v("h2",{attrs:{id:"事务失效的原因"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务失效的原因"}},[_._v("#")]),_._v(" 事务失效的原因")]),_._v(" "),v("p",[_._v("主要是这八点：")]),_._v(" "),v("ol",[v("li",[_._v("数据库引擎是否支持事务(比如MyISAM就不支持事务）")]),_._v(" "),v("li",[_._v("注解所在的类是否被加载成Bean")]),_._v(" "),v("li",[_._v("注解所在的方法是否为public所修饰")]),_._v(" "),v("li",[_._v("是否发生了自调用机制——同一个类之中的方法相互调用")]),_._v(" "),v("li",[_._v("所用的数据源是否加载了事务管理器")]),_._v(" "),v("li",[v("code",[_._v("@Transactional")]),_._v("的扩展配置propagation是否正确（七种传播行为）")]),_._v(" "),v("li",[_._v("异常被吃掉了——自己try自己catch")]),_._v(" "),v("li",[_._v("异常抛出错误——抛的不是RuntimeException")])])])}),[],!1,null,null,null);t.default=r.exports}}]);