---
title: 语言基础
date: 2021-03-20 15:46:19
permalink: /pages/1b02b4/
categories:
  - 程序语言
  - Go
tags:
  - 
---

## 函数调用

这里面涉及的东西其实挺深的，所以等我后面又时间再去研究

## 接口

接口的本质是引入一个新的中间层，调用方可以通过接口与具体实现分离，解除上下游的耦合，上层的模块不再需要依赖下层的具体模块，只需要依赖一个约定好的接口。

![golang-interface](https://img.xiaoyou66.com/2021/03/26/1e5f5bbdd096b.png)

我们可以使用结构体指针或者结构体来实现接口，但是默认情况下，还是推荐使用指针

```go
type Cat struct {}
type Duck interface { ... }

func (c  Cat) Quack {}  // 使用结构体实现接口
func (c *Cat) Quack {}  // 使用结构体指针实现接口

var d Duck = Cat{}      // 使用结构体初始化变量
var d Duck = &Cat{}     // 使用结构体指针初始化变量
```

|    结构体实现接口    | 结构体指针实现接口 |        |
| :------------------: | :----------------: | ------ |
|   结构体初始化变量   |        通过        | 不通过 |
| 结构体指针初始化变量 |        通过        | 通过   |

后面一些东西过于底层，所以先暂时跳过

## 反射

[`reflect`](https://golang.org/pkg/reflect/) 实现了运行时的反射能力，包括动态修改变量、判断类型是否实现了某些接口以及动态调用方法等功能。能够让程序操作不同类型的对象[1](https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/#fn:1)。反射包中有两对非常重要的函数和类型，两个函数分别是：

- [`reflect.TypeOf`](https://draveness.me/golang/tree/reflect.TypeOf) 能获取类型信息；
- [`reflect.ValueOf`](https://draveness.me/golang/tree/reflect.ValueOf) 能获取数据的运行时表示；

```go
func Test_question(t *testing.T) {
   a:=456
   fmt.Println(reflect.TypeOf(a))
   fmt.Println(reflect.ValueOf(a))
   /*
   * int
   * 456
   */
}
```

### 反射的三大法则

1. 从 `interface{}` 变量可以反射出反射对象；
2. 从反射对象可以获取 `interface{}` 变量；
3. 要修改反射对象，其值必须可设置；

