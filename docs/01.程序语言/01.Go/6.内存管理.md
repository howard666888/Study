---
title: 内存管理
date: 2021-03-20 15:46:19
permalink: /pages/18d2d0/
categories:
  - 程序语言
  - Go
tags:
  - 
---

## 内存分配

程序中的数据和变量都会被分配到程序所在的虚拟内存中，内存空间包含两个重要区域：栈区（Stack）和堆区（Heap）。函数调用的参数、返回值以及局部变量大都会被分配到栈上，这部分内存会由编译器进行管理；其他的比如对象则由内存分配器分配并由垃圾收集器回收。

### 基本概念

#### 内存管理由三部分组成

1. 用户程序（Mutator）
2. 分配器（Allocator）
3. 收集器（Collector）

当 **用户程序申请内存** 时，它会通过 **内存分配器申请新内存** ，而分配器会负责从堆中初始化相应的内存区域。收集器就负责回收垃圾

![mutator-allocator-collector](https://img.xiaoyou66.com/2021/03/26/8d1550bb488f5.png)

#### 分配的方法

内存分配主要分为下面两种方法

- **线性分配器（Sequential Allocator，Bump Allocator）** 维护一大块内存，需要的时候就从这块内存中去分配，实现比较简单，但是已经分配的内存无法重新利用（需要配合垃圾回收算法使用）

  ![bump-allocator-reclaim-memory](https://img.xiaoyou66.com/2021/03/26/537664307a682.png)

- **空闲链表分配器（Free-List Allocator）** 这个可以重用已经释放过的内存，内部会维护一个链表的结构，申请内存时会依次遍历空闲的内存块，找到足够大的内存，然后申请新的资源并修改链表

  ![free-list-allocator](https://img.xiaoyou66.com/2021/03/26/25e674a1a13b0.png)

链表分配器有四种分配策略

- 首次适应（First-Fit）— 从链表头开始遍历，选择第一个大小大于申请内存的内存块；
- 循环首次适应（Next-Fit）— 从上次遍历的结束位置开始遍历，选择第一个大小大于申请内存的内存块；
- 最优适应（Best-Fit）— 从链表头遍历整个链表，选择最合适的内存块；
- 隔离适应（Segregated-Fit）— 将内存分割成多个链表，每个链表中的内存块大小相同，申请内存时先找到满足条件的链表，再从链表中选择合适的内存块

**go使用的是类似于隔离适应的策略，下图是这个策略的简单介绍**

![segregated-list](https://img.xiaoyou66.com/2021/03/26/4a9671966347a.png)

#### 如何分配

上面说了一下内存分配的方法，下面简单介绍一下内存是如何分配的，go借鉴线程缓存分配（Thread-Caching Malloc，TCMalloc）的方法来进行内存分配，它的核心理念是使用多级缓存将对象根据大小分类，并按照类别实施不同的分配策略。

Go 语言的内存分配器会根据 **申请分配的内存大小选择不同的处理逻辑** ，运行时根据对象的大小将对象分成微对象、小对象和大对象三种（因为程序中的绝大多数对象的大小都在 32KB 以下，而申请的内存大小影响 Go 语言运行时分配内存的过程和开销，所以分别处理大对象和小对象有利于提高内存分配器的性能。）

|  类别  |     大小      |
| :----: | :-----------: |
| 微对象 |  `(0, 16B)`   |
| 小对象 | `[16B, 32KB]` |
| 大对象 | `(32KB, +∞)`  |

内存分配器不仅会区别对待大小不同的对象，还会 **将内存分成不同的级别分别管理** ，TCMalloc 和 Go 运行时分配器都会引入线程缓存（Thread Cache）、中心缓存（Central Cache）和页堆（Page Heap）三个组件分级管理内存，示意图如下

![multi-level-cache](https://img.xiaoyou66.com/2021/03/26/493eaff280ff8.png)

线程缓存属于每一个独立的线程，它能够满足线程上绝大多数的内存分配需求，因为不涉及多线程，所以也不需要使用互斥锁来保护内存，这能够减少锁竞争带来的性能损耗。当线程缓存不能满足需求时，运行时会使用中心缓存作为补充解决小对象的内存分配，在遇到 32KB 以上的对象时，内存分配器会选择页堆直接分配大内存。

#### 虚拟内存布局

前面说了分配的方法和如何分配，下面说一下go的堆区内存是如何布局的

go1.10之前使用的是线性内存，虽然简单且方便，但是c和go混用的时候会导致程序奔溃。所以下面要讲的是Go的1.11提出的稀疏内存。

![heap-after-go-1-11](https://img.xiaoyou66.com/2021/03/26/1528335631758.png)

使用稀疏的内存布局不仅能移除堆大小的上限[5](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/#fn:5)，还能解决 C 和 Go 混合使用时的地址空间冲突问题[6](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/#fn:6)。不过因为基于稀疏内存的内存管理失去了内存的连续性这一假设，这也使内存管理变得更加复杂，由于内存的管理变得更加复杂，上述改动对垃圾回收稍有影响，大约会增加 1% 的垃圾回收开销，不过这也是我们为了解决已有问题必须付出的成本[7](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/#fn:7)。

#### 地址空间

因为所有的内存最终都是要从操作系统中申请的，所以 Go 语言的运行时构建了操作系统的内存管理抽象层，该抽象层将运行时管理的地址空间分成以下四种状态[8](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/#fn:8)：

|    状态    |                             解释                             |
| :--------: | :----------------------------------------------------------: |
|   `None`   |         内存没有被保留或者映射，是地址空间的默认状态         |
| `Reserved` |        运行时持有该地址空间，但是访问该内存会导致错误        |
| `Prepared` | 内存被保留，一般没有对应的物理内存访问该片内存的行为是未定义的可以快速转换到 `Ready` 状态 |
|  `Ready`   |                        可以被安全访问                        |

### 内存管理组件

前面说了一些基本概念，这里就总结一下整个GO的内存分配器结构

Go 语言的内存分配器包含内存管理单元、线程缓存、中心缓存和页堆几个重要组件，整个结构图如下

![go-memory-layout](https://img.xiaoyou66.com/2021/03/26/48b092c6c5205.png)

所有的 Go 语言程序都会在启动时初始化如上图所示的内存布局，每一个处理器都会分配一个线程缓存 [`runtime.mcache`](https://draveness.me/golang/tree/runtime.mcache) 用于处理微对象和小对象的分配，它们会持有内存管理单元 [`runtime.mspan`](https://draveness.me/golang/tree/runtime.mspan)。

每个类型的内存管理单元都会管理特定大小的对象，当内存管理单元中不存在空闲对象时，它们会从 [`runtime.mheap`](https://draveness.me/golang/tree/runtime.mheap) 持有的 134 个中心缓存 [`runtime.mcentral`](https://draveness.me/golang/tree/runtime.mcentral) 中获取新的内存单元，中心缓存属于全局的堆结构体 [`runtime.mheap`](https://draveness.me/golang/tree/runtime.mheap)，它会从操作系统中申请内存。

在 amd64 的 Linux 操作系统上，[`runtime.mheap`](https://draveness.me/golang/tree/runtime.mheap) 会持有 4,194,304 [`runtime.heapArena`](https://draveness.me/golang/tree/runtime.heapArena)，每个 [`runtime.heapArena`](https://draveness.me/golang/tree/runtime.heapArena) 都会管理 64MB 的内存，单个 Go 语言程序的内存上限也就是 256TB。



## 垃圾收集

### 基本概念

在开始介绍之前需要先一些基本的概念，方便对后面的内容进行理解

#### 标记清除

标记清除（Mark-Sweep）算法是最常见的垃圾收集算法，标记清除收集器是跟踪式垃圾收集器，其执行过程可以分成标记（Mark）和清除（Sweep）两个阶段。

#### 三色抽象

为了解决原始标记清除算法带来的长时间 STW，多数现代的追踪式垃圾收集器都会实现三色标记算法的变种以 **缩短 STW 的时间**  三色标记算法将程序中的对象分成白色、黑色和灰色三类：

- 白色对象 — 潜在的垃圾，其内存可能会被垃圾收集器回收；
- 黑色对象 — 活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象；
- 灰色对象 — 活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象；

![tri-color-objects](https://img.xiaoyou66.com/2021/03/26/d76b9df6cb7b4.png)

三色标记垃圾收集器的工作原理很简单，我们可以将其归纳成以下几个步骤：

1. 从灰色对象的集合中选择一个灰色对象并将其标记成黑色；
2. 将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收；
3. 重复上述两个步骤直到对象图中不存在灰色对象；

当标记结束后，应用程序就不存在任何的灰色对象，这个时候，垃圾收集器就会回收白色垃圾。

使用三色标记时，为了避免用户程序修改对象指针，所以我们需要STW，如果想并发或者增量来标记对象时，我们需要使用屏障技术

#### 屏障技术

内存屏障技术是一种屏障指令，它可以让 CPU 或者编译器在执行内存相关操作时遵循特定的约束，目前多数的现代处理器都会乱序执行指令以最大化性能，但是该技术能够保证内存操作的顺序性，在内存屏障前执行的操作一定会先于内存屏障后执行的操作[6](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#fn:6)。

要想在并发标记时确保正确性，我们就必须要达成下面两种三色不变性中的一种：

- 强三色不变性 — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；
- 弱三色不变性 — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径

下图展示了这两种三色不变性：

![strong-weak-tricolor-invariant](https://img.xiaoyou66.com/2021/03/26/613cef16020e6.png)

怎么保证三色不变性呢？答案是使用屏障技术

垃圾收集中的屏障技术更像是一个钩子方法，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，根据操作类型的不同，我们可以将它们分成读屏障（Read barrier）和写屏障（Write barrier）两种，因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，**所以编程语言往往都会采用写屏障保证三色不变性。**

Go 语言中使用的两种写屏障技术，分别是 Dijkstra 提出的插入写屏障[8](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#fn:8)和 Yuasa 提出的删除写屏障[9](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#fn:9)。

具体过程就不细表，可以参考：[Go 语言垃圾收集器的实现原理 | Go 语言设计与实现 (draveness.me)](https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#插入写屏障)

#### 增量和并发

传统的垃圾收集算法会在垃圾收集的执行期间暂停应用程序，一旦触发垃圾收集，垃圾收集器会抢占 CPU 的使用权占据大量的计算资源以完成标记和清除工作，然而很多追求实时的应用程序无法接受长时间的 STW，而现在我们计算机往往是多核的，所以我们可以使用下面两种策略来优化我们的垃圾回收器：

- 增量垃圾收集 — 增量地标记和清除垃圾，降低应用程序暂停的最长时间；（把原本较长的暂停时间切分为多个更小的时间片）
- 并发垃圾收集 — 利用多核的计算资源，在用户程序执行时并发标记和清除垃圾；（收集器直接和程序一起运行，但是部分阶段也需要暂停程序）

因为增量和并发两种方式都可以与用户程序交替运行，所以我们需要**使用屏障技术**保证垃圾收集的正确性；与此同时，增量和并发的垃圾收集需要提前触发并在内存不足前完成整个循环，避免程序的长时间暂停。

演进过程，这部分内容比较多，所以就不展开讲了，直接跳到最新的垃圾回收器

### 实现原理

1. 清理终止阶段；
   1. **暂停程序**，所有的处理器在这时会进入安全点（Safe point）；
   2. 如果当前垃圾收集循环是强制触发的，我们还需要处理还未被清理的内存管理单元；
2. 标记阶段；
   1. 将状态切换至 `_GCmark`、开启写屏障、用户程序协助（Mutator Assiste）并将根对象入队；
   2. 恢复执行程序，标记进程和用于协助的用户程序会开始并发标记内存中的对象，写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新创建的对象都会被直接标记成黑色；
   3. 开始扫描根对象，包括所有 Goroutine 的栈、全局对象以及不在堆中的运行时数据结构，扫描 Goroutine 栈期间会暂停当前处理器；
   4. 依次处理灰色队列中的对象，将对象标记成黑色并将它们指向的对象标记成灰色；
   5. 使用分布式的终止算法检查剩余的工作，发现标记阶段完成后进入标记终止阶段；
3. 标记终止阶段；
   1. **暂停程序**、将状态切换至 `_GCmarktermination` 并关闭辅助标记的用户程序；
   2. 清理处理器上的线程缓存；
4. 清理阶段；
   1. 将状态切换至 `_GCoff` 开始清理阶段，初始化清理状态并关闭写屏障；
   2. 恢复用户程序，所有新创建的对象会标记成白色；
   3. 后台并发清理所有的内存管理单元，当 Goroutine 申请新的内存管理单元时就会触发清理；

#### 触发时机

- **后台触发** 运行时会在应用程序启动时在后台开启一个用于强制触发垃圾收集的 Goroutine，该 Goroutine 的职责非常简单 — 调用 [`runtime.gcStart`](https://draveness.me/golang/tree/runtime.gcStart) 尝试启动新一轮的垃圾收集。（这个线程大部分是休眠状态，但是会被系统监视器在满足条件时唤醒）

- **手动触发**  用户程序会通过 [`runtime.GC`](https://draveness.me/golang/tree/runtime.GC) 函数在程序运行期间主动通知运行时执行，该方法在调用时会阻塞调用方直到当前垃圾收集循环完成，在垃圾收集期间也可能会通过 STW 暂停整个程序

- **申请内存** 申请内存时也可以触发垃圾回收

#### 内存清理

垃圾收集的清理中包含对象回收器（Reclaimer）和内存单元回收器，这两种回收器使用不同的算法清理堆内存：

- 对象回收器在内存管理单元中查找并释放未被标记的对象，但是如果 [`runtime.mspan`](https://draveness.me/golang/tree/runtime.mspan) 中的所有对象都没有被标记，整个单元就会被直接回收，该过程会被 [`runtime.mcentral.cacheSpan`](https://draveness.me/golang/tree/runtime.mcentral.cacheSpan) 或者 [`runtime.sweepone`](https://draveness.me/golang/tree/runtime.sweepone) 异步触发；
- 内存单元回收器会在内存中查找所有的对象都未被标记的 [`runtime.mspan`](https://draveness.me/golang/tree/runtime.mspan)，该过程会被 [`runtime.mheap.reclaim`](https://draveness.me/golang/tree/runtime.mheap.reclaim) 触发；

## 栈内存管理

栈区的内存一般由编译器自动分配和释放，其中存储着函数的入参以及局部变量，这些参数会随着函数的创建而创建，函数的返回而消亡，一般不会在程序中长期存在，这种线性的内存分配策略有着极高地效率，但是工程师也往往不能控制栈内存的分配，这部分工作基本都是由编译器完成的。



