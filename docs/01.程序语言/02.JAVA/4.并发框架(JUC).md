---
title: 并发框架(JUC)
date: 2021-03-20 15:46:19
permalink: /pages/f47c61/
categories:
  - 程序语言
  - JAVA
tags:
  - 
---

并发框架，其实也叫 JUC 即 `java.util.concurrent` 包，分为（锁框架、原子类框架、同步器框架、集合框架、执行器框架）

## 线程创建方式

- 继承`Thread`类重写run方法

  ```java
  public class Thread1 extends Thread {
      /**
       * 在run方法中实现业务代码
       */
      @Override
      public void run(){
          System.out.println(Thread.currentThread().getName()+"我是子线程");
  
      }
      public static void main(String[] args) {
          System.out.println(Thread.currentThread().getName()+"我是主线程");
          //不能直接使用run()方法，这就不属于开启线程，而是调用一个方法
          new Thread1().start();
      }
  }
  ```

- 实现`Runnable`接口

  ```java
  public class Thread2 implements Runnable {
      /**
       * 在run方法中实现业务代码
       */
      @Override
      public void run() {
          System.out.println(Thread.currentThread().getName() + "我是子线程");
      }
      public static void main(String[] args) {
          System.out.println(Thread.currentThread().getName() + "我是主线程");
          //这里要通过new Thread()的方式来开启
          new Thread(new Thread2()).start();
          //简化版 lambdas
          new Thread(() -> System.out.println(Thread.currentThread().getName() + "我是子线程")).start();
      }
  }
  
  ```

- 继承`Callable`

  ```java
  public class Thread3 implements Callable<String> {
      @Override
      public String call() throws Exception {
          try {
              System.out.println(Thread.currentThread().getName() + "我是子线程");
              Thread.sleep(2000);
          } catch (Exception e) {
              System.out.println(e.getMessage());
          }
          return "异步调用成功";
      }
  
      public static void main(String[] args) throws ExecutionException, InterruptedException {
          FutureTask<String> futureTask = new FutureTask<>(new Thread3());
          new Thread(futureTask).start();
          System.out.println(futureTask.get());
      }
  } 
  ```

- 使用线程池

参考：[线程学习1（小白自学）_冷雨清的博客-CSDN博客](https://blog.csdn.net/weixin_44777669/article/details/108813951)

## 线程的5种状态

![在这里插入图片描述](https://img.xiaoyou66.com/2021/03/23/f08bc7d0ca9d4.png)

## synchronized关键字

synchronized可以修饰**实例方法**、**静态方法**、**代码块**，只需要加个关键字就行了

```java
public class Test {
    // 这里我们修饰了静态方法
    public synchronized void husband(){
    }
}
```

### 锁升级过程

因为默认synchronized是一个重锁，使用起来非常消耗性能，但是后面的版本优化了不少，具体过程如下：

无锁->偏向锁->轻量级锁 ->重量级锁 （过程不可逆）

参考：[死磕Synchronized底层实现 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453142528&idx=1&sn=34b26e408e1f8adcd8d8257522705171)

## Volatile关键字

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：

- 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。

- 禁止进行指令重排序（为了提高性能，CPU会修改指令的执行顺序）。

### Volatile如何保证指令不会重排序

使用了内存屏障技术，在生成指令系列时在适当的位置会插入`内存屏障`指令来禁止特定类型的处理器重排序。

### 可见性是如何保证的

使用了 **MESI（IllinoisProtocol 缓存一致性协议）** 来保证指令一致性

> 当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。
>
> 怎么发现数据是否失效？（使用了嗅探技术）

### 运用

单例模式里面用的到，单例有8种写法，其中有一种叫双重检验用到了这个

![image-20210323102329952](https://img.xiaoyou66.com/2021/03/23/e60fff5a75c8a.png)

参考：[面试官想到，一个Volatile，敖丙都能吹半小时 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453142004&idx=1&sn=81ccddb6c8b37114c022c4ad50368ecf)

## 阻塞队列

默认使用的队列都是非阻塞的，不会阻塞当前线程，而阻塞队列会阻塞当前线程， **常用于线程池和生产者消费者的问题中**

当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满；从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空。

**延时阻塞队列（DelayQueue）**  只有当其指定的延迟时间到了，才能够从队列中获取到该元素

深入参考：[Java并发编程-阻塞队列(BlockingQueue)的实现原理_记忆力不好的博客-CSDN博客_阻塞队列原理](https://blog.csdn.net/chenchaofuck1/article/details/51660119)

## ThreadLocal

通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想实现每一个线程都有自己的专属本地变量该如何解决呢？ 使用**ThreadLocal**类。 ThreadLocal可以让每个线程绑定自己的值。

![image.png](https://img.xiaoyou66.com/2021/03/23/a91165f5123c1.png)

- 使用 `get（）` 和 `set（）` 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。

- 每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为key的键值对，value其实就是我们存储数据的地方

#### ThreadLocal内存泄露的问题

- 使用static的ThreadLocal，延长了ThreadLocal的生命周期，可能导致内存泄漏。
- 分配使用了ThreadLocal又不再调用get(),set(),remove()方法，那么就会导致内存泄漏，因为这块内存一直存在。

**原因**

ThreadLocal在保存的时候会把自己当做Key存在ThreadLocalMap中，正常情况应该是key和value都应该被外界强引用才对，但是现在key被设计成WeakReference弱引用了。

参考：[JUC学习：ThreadLocal_冷雨清的博客-CSDN博客](https://blog.csdn.net/weixin_44777669/article/details/109511569)

## Java里面的各种锁

参考：[java中的各种锁详细介绍 - JYRoy - 博客园 (cnblogs.com)](https://www.cnblogs.com/jyroy/p/11365935.html)

