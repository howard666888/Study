---
title: 并发框架(JUC)
date: 2021-03-20 15:46:19
permalink: /pages/f47c61/
categories:
  - 程序语言
  - JAVA
tags:
  - 
---

并发框架，其实也叫 JUC 即 `java.util.concurrent` 包，分为（锁框架、原子类框架、同步器框架、集合框架、执行器框架）

## 线程创建方式

- 继承`Thread`类重写run方法

  ```java
  public class Thread1 extends Thread {
      /**
       * 在run方法中实现业务代码
       */
      @Override
      public void run(){
          System.out.println(Thread.currentThread().getName()+"我是子线程");
  
      }
      public static void main(String[] args) {
          System.out.println(Thread.currentThread().getName()+"我是主线程");
          //不能直接使用run()方法，这就不属于开启线程，而是调用一个方法
          new Thread1().start();
      }
  }
  ```

- 实现`Runnable`接口

  ```java
  public class Thread2 implements Runnable {
      /**
       * 在run方法中实现业务代码
       */
      @Override
      public void run() {
          System.out.println(Thread.currentThread().getName() + "我是子线程");
      }
      public static void main(String[] args) {
          System.out.println(Thread.currentThread().getName() + "我是主线程");
          //这里要通过new Thread()的方式来开启
          new Thread(new Thread2()).start();
          //简化版 lambdas
          new Thread(() -> System.out.println(Thread.currentThread().getName() + "我是子线程")).start();
      }
  }
  
  ```

- 继承`Callable`

  ```java
  public class Thread3 implements Callable<String> {
      @Override
      public String call() throws Exception {
          try {
              System.out.println(Thread.currentThread().getName() + "我是子线程");
              Thread.sleep(2000);
          } catch (Exception e) {
              System.out.println(e.getMessage());
          }
          return "异步调用成功";
      }
  
      public static void main(String[] args) throws ExecutionException, InterruptedException {
          FutureTask<String> futureTask = new FutureTask<>(new Thread3());
          new Thread(futureTask).start();
          System.out.println(futureTask.get());
      }
  } 
  ```

- 使用线程池

参考：[线程学习1（小白自学）_冷雨清的博客-CSDN博客](https://blog.csdn.net/weixin_44777669/article/details/108813951)

## 线程的5种状态

![在这里插入图片描述](https://img.xiaoyou66.com/2021/03/23/f08bc7d0ca9d4.png)

## synchronized关键字

synchronized可以修饰**实例方法**、**静态方法**、**代码块**，只需要加个关键字就行了

```java
public class Test {
    // 这里我们修饰了静态方法
    public synchronized void husband(){
    }
}
```

### 锁升级过程

因为默认synchronized是一个重锁，使用起来非常消耗性能，但是后面的版本优化了不少，具体过程如下：

无锁->偏向锁->轻量级锁 ->重量级锁 （过程不可逆）

参考：[死磕Synchronized底层实现 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453142528&idx=1&sn=34b26e408e1f8adcd8d8257522705171)

## Volatile关键字

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：

- 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。

- 禁止进行指令重排序（为了提高性能，CPU会修改指令的执行顺序）。

### Volatile如何保证指令不会重排序

使用了内存屏障技术，在生成指令系列时在适当的位置会插入`内存屏障`指令来禁止特定类型的处理器重排序。

### 可见性是如何保证的

使用了 **MESI（IllinoisProtocol 缓存一致性协议）** 来保证指令一致性

> 当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。
>
> 怎么发现数据是否失效？（使用了嗅探技术）

### 运用

单例模式里面用的到，单例有8种写法，其中有一种叫双重检验用到了这个

![image-20210323102329952](https://img.xiaoyou66.com/2021/03/23/e60fff5a75c8a.png)

参考：[面试官想到，一个Volatile，敖丙都能吹半小时 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453142004&idx=1&sn=81ccddb6c8b37114c022c4ad50368ecf)

## final关键字



## 阻塞队列

默认使用的队列都是非阻塞的，不会阻塞当前线程，而阻塞队列会阻塞当前线程， **常用于线程池和生产者消费者的问题中**

当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满；从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空。

**延时阻塞队列（DelayQueue）**  只有当其指定的延迟时间到了，才能够从队列中获取到该元素

深入参考：[Java并发编程-阻塞队列(BlockingQueue)的实现原理_记忆力不好的博客-CSDN博客_阻塞队列原理](https://blog.csdn.net/chenchaofuck1/article/details/51660119)

## ThreadLocal

通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。如果想实现每一个线程都有自己的专属本地变量该如何解决呢？ 使用**ThreadLocal**类。 ThreadLocal可以让每个线程绑定自己的值。

![image.png](https://img.xiaoyou66.com/2021/03/23/a91165f5123c1.png)

- 使用 `get（）` 和 `set（）` 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。

- 每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为key的键值对，value其实就是我们存储数据的地方

#### ThreadLocal内存泄露的问题

- 使用static的ThreadLocal，延长了ThreadLocal的生命周期，可能导致内存泄漏。
- 分配使用了ThreadLocal又不再调用get(),set(),remove()方法，那么就会导致内存泄漏，因为这块内存一直存在。

**原因**

ThreadLocal在保存的时候会把自己当做Key存在ThreadLocalMap中，正常情况应该是key和value都应该被外界强引用才对，但是现在key被设计成WeakReference弱引用了。

参考：[JUC学习：ThreadLocal_冷雨清的博客-CSDN博客](https://blog.csdn.net/weixin_44777669/article/details/109511569)

## Java里面的各种锁

参考：[java中的各种锁详细介绍 - JYRoy - 博客园 (cnblogs.com)](https://www.cnblogs.com/jyroy/p/11365935.html)

## 线程池

J.U.C提供的线程池：ThreadPoolExecutor类

**线程池的好处**

- **降低资源消耗**：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。
- **提高响应速度**：任务到达时，无需等待线程创建即可立即执行。
- **提高线程的可管理性**：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。
- **提供更多更强大的功能**：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。

### 常用线程池

1. Executors.newCachedThreadPool()  可缓存线程池
2. Executors.newFixedThreadPool(int n)：创建一个可重用固定个数的线程池。
3. Executors.newScheduledThreadPool(int n)：创建一个定长线程池，支持定时及周期性任务执行。
4. xecutors.newSingleThreadExecutor()：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。

### 线程池使用

```java
// 创建固定大小的线程池:
ExecutorService executor = Executors.newFixedThreadPool(3);
// 提交任务: 返回一个future。可以用这个future来判断任务是否成功完成
executor.submit(task1);
// 提交任务: 没有返回值。可以执行任务，但无法判断任务是否成功完成。
executor.execute(task1);
// 关闭线程池: 在线程池队列中的提交的任务会执行，无法提交新的任务，注意调用这个方法，线程池不会等待（wait）在执行的任务执行完成，可以使用awaitTermination实现这个目的。这里需要注意的是：在执行的任务因为是异步线程执行的，任务还是会继续执行，只是说线程池不会阻塞等待任务执行完成
executor.shutdown();
// 试图关闭正在执行的任务，不会执行已经提交到队列但是还没有执行的任务，返回等待执行的任务列表，同时此方法不会等待那些正在执行的任务执行完，等待执行的任务会从线程池队列移除。
executor.shutdownNow()

```

### 线程池参数

```java
public ThreadPoolExecutor(int corePoolSize,  // 线程池的核心线程数
                          int maximumPoolSize, // 线程池的最大线程数
                          long keepAliveTime, // 当线程数大于核心时，多余的空闲线程等待新任务的存活时间。
                          TimeUnit unit, // keepAliveTime的时间单位
                          ThreadFactory threadFactory, // 线程工厂
                          BlockingQueue<Runnable> workQueue,// 用来储存等待执行任务的队列
                          RejectedExecutionHandler handler // 拒绝策略
                          ) 
```

- **corePoolSize**  线程池保留的最小线程数。如果线程池中的线程少于此数目，则在执行execut()时创建。

- **maximumPoolSize**  线程池中允许拥有的最大线程数。

- **keepAliveTime、unit** 只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用

  当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的线程数为0；

- **threadFactory ** 使用默认的即可

- **workQueue** 工作队列，存放提交的等待任务，其中有队列大小的限制

- **handler** 拒绝策略，有以下四种取值：
  AbortPolicy（默认）：丢弃任务并抛出RejectedExecutionException异常。
  CallerRunsPolicy：由调用线程处理该任务。(例如io操作，线程消费速度没有NIO快，可能导致阻塞队列一直增加，此时可以使用这个模式)
  DiscardPolicy：丢弃任务，但是不抛出异常。 （可以配合这种模式进行自定义的处理方式）
  DiscardOldestPolicy：丢弃队列最早的未处理任务，然后重新尝试执行任务（重复执行）

参考：

1. [Java线程池实现原理及其在美团业务中的实践 - 美团技术团队 (meituan.com)](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)
2. [java常用线程池 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/92790574)
3. [Java中如何正确的关闭线程池ExecutorService_zlp1992的专栏-CSDN博客](https://blog.csdn.net/zlp1992/article/details/104197515)
4. [线程池的参数详解_meihuai7538的博客-CSDN博客_线程池参数](https://blog.csdn.net/meihuai7538/article/details/104876674)

## 线程阻塞

线程阻塞的几个方法

- **线程睡眠** Thread.sleep (long millis)方法当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。

- **线程等待**  Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 唤醒方法。

- **线程礼让** Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程.

- **线程自闭** join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。

- **suspend() 和 resume()**   两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。**Thread中suspend()和resume()两个方法在JDK1.5中已经废除**，不再介绍。因为有死锁倾向。

![image.png](https://img.xiaoyou66.com/2021/03/23/a1eb1a5d42116.png)

参考：[Java中什么方法导致线程阻塞_Chin_Style的博客-CSDN博客_java 线程阻塞](https://blog.csdn.net/weixin_41101173/article/details/79679300)

## AQS

也叫AbstractQueuedSynchronizer（AQS），是一个抽象的队列式同步器，AQS定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它（很多锁也是基于这个框架的），AQS示意图如下

![img](https://img.xiaoyou66.com/2021/03/29/3cb6b9426f9f9.png)

它维护了一个volatile int state（代表共享资源，使用volatile修饰）和一个FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。

节点的示意图如下

![image-20210329162754753](https://img.xiaoyou66.com/2021/03/29/df554a726285e.png)

### 相关属性和资源共享方式

**state的访问方式有三种**

- getState()
- setState()
- compareAndSetState()

AQS有**两种资源的共享方式**

- Exclusive（独占，只有一个线程能执行，如ReentrantLock）
- Share（共享，多个线程可同时执行，如Semaphore/CountDownLatch）

不同的自定义同步器争用共享资源的方式也不同。**自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可**，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：

- isHeldExclusively()：该线程是否正在独占资源。只有用到condition才需要去实现它。
- tryAcquire(int)：独占方式。尝试获取资源，成功则返回true，失败则返回false。
- tryRelease(int)：独占方式。尝试释放资源，成功则返回true，失败则返回false。
- tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
- tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。

**以ReentrantLock为例**，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。

一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。

### 节点状态

队列里面放的是节点，而节点是对每一个等待获取资源的线程的封装，其包含了需要同步的线程本身及其等待状态，如是否被阻塞、是否等待唤醒、是否已经被取消等。变量waitStatus则表示当前Node结点的等待状态，共有5种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE、0。

- **CANCELLED**(1)：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。
- **SIGNAL**(-1)：表示后继结点在等待当前结点唤醒。后继结点入队时，会将前继结点的状态更新为SIGNAL。
- **CONDITION**(-2)：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将**从等待队列转移到同步队列中**，等待获取同步锁。
- **PROPAGATE**(-3)：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。
- **0**：新结点入队时的默认状态。

> 注意，**负值表示结点处于有效等待状态，而正值表示结点已被取消。所以源码中很多地方用>0、<0来判断结点的状态是否正常**。

### 方法流程解读

下面我们按照独占和共享两种不同的方式来讲解里面的内容

#### 获取独占资源

![img](https://img.xiaoyou66.com/2021/03/29/1fc605c88d512.png)

#### 释放独占资源

此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源

#### 获取共享资源





参考：

1. [Java并发之AQS详解 - waterystone - 博客园 (cnblogs.com)](https://www.cnblogs.com/waterystone/p/4920797.html)

