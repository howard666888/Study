---
title: 垃圾回收
date: 2021-03-20 15:46:19
permalink: /pages/2502a4/
categories:
  - 程序语言
  - JAVA
tags:
  - 
---

## 判断对象是否是垃圾

### 引用计数算法：判断对象的引用数量

每引用一次就+1，当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数减 1，当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器均减 1，当引用次数为0时就会当成垃圾，

**问题**  当两个对象循环引用时，这个垃圾就无法回收

### 可达性分析算法：判断对象的引用链是否可达

通过一系列的名为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）。当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的

![img](https://img.xiaoyou66.com/2021/03/23/1979a28681ca1.jpg)





## 垃圾回收三种算法

标记删除（mark-sweep）、拷贝（copying）、标记压缩（mark-compact）

- **标记删除**  就是把垃圾区域标记出来，然后清除出去（问题：碎片化）
- **拷贝** 先将内存分成俩半，把要清除的一半有用的区域复制到另一半，然后清除这一半（浪费空间）
- **标记整理** 对内存进行整理，有用的堆到前面，没用的堆到后面，一边标记一边整理（效率低）
- **分代收集** 不同的对象生命周期不一样，我们可以通过分成不同的代，不同代使用不同的算法（新生代使用拷贝 老年代使用标记整理）

JVM是拷贝和标记整理两个算法结合使用

## Java堆内存逻辑分区（分代模型）

![image-20210323111431114](https://img.xiaoyou66.com/2021/03/23/f040c4f6128b4.png)

- 内存分为俩大块，一个是新生代区域，一个是老年代区域。
- 新生代包括伊甸区、survivor1和survivor2
- 老年代只有一块，但是占的空间更大

### 详细流程

1. 当我们初始化一个对象时，首先会判断是否可以分配到栈上，如果可以就直接分配到栈上，不行就下一步
2. 然后判断是不是大对象，大对象可以直接分配到老年代，小对象需要判断是否启动了本地线程分配缓存(TLAB)，如果有则将按线程优先在TLAB上分配。
3. 然后就是回收了，一开始垃圾回收器会把S2和伊甸区有用的数据都复制S1中（这里用到了垃圾回收的拷贝），然后清空伊甸区和S2，第二次GC时会把S1和伊甸区的有用的对象都放入S2中，然后清空S1和伊甸区，如此循环往复。
4. 新生代每次GC年龄都会增长1，当年龄到达15时会进入老年代（老年代采用的是标记整理算法）

![image-20210311100052826](https://img.xiaoyou66.com/2021/03/23/f47791111b4b1.png)

TLAB：Thread Local Allocation Buffer（线程本地分配缓冲区）eden区有一个线程本地缓冲空间，避免争抢，如果线程需要，就new到线程自己身上去

## 垃圾回收器

垃圾回收器其实就是**进行垃圾回收算法时**  用于垃圾标记的算法

![image-20210310222838854](https://img.xiaoyou66.com/2021/03/23/00ec8ab4bb92a.png)

1. Epslion：最没用的，就是个摆设，就调试用的到（Debug）
2. Parallel Scavenge：采用多线程切GC
3. Parallel Old：采用多线程切GC
4. Serial：stw（stop the world）单线程，停止工作线程，进行GC（很少用了）
5. Serial Old：单线程，停止工作线程，进行GC（很少用了）
6. CMS(重点！！！！)：工作在老年代
7. ParNew：和Parallel Scavenge一样，只不过是用来配合CMS
8. G1：针对分区模型的回收器
9. ZGC：针对分区模型的回收器
10. Shenandosh：针对分区模型的回收器

## CMS

用于回收老年代的垃圾

- 初始标记：标记老年代root对象
- 并发标记：对root对象往下进行标记
- 重新标记：修正错标的内容（三色标记算法）
- 并发清理：清理垃圾，也会产生浮动垃圾，下次处理

注意：这里标记的时候会STW，把当前的进程停止，然后进行标记，然后在恢复线程（蓝色的就是我们的实际线程了，黄色的是标记和垃圾回收线程）

![image-20210312214042432](https://img.xiaoyou66.com/2021/03/23/5dab2b981f8b8.png)

参考

1.  [JVM基础知识和调优_冷雨清的博客-CSDN博客_jvm调优](https://blog.csdn.net/weixin_44777669/article/details/114745089)
2. [图解Java 垃圾回收机制_Rico's Blogs-CSDN博客_java垃圾回收机制](https://blog.csdn.net/justloveyou_/article/details/71216049)





