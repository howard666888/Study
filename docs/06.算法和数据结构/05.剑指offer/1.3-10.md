---
title: 3-10
date: 2021-03-29 08:56:23
permalink: /pages/279e94/
categories:
  - 算法和数据结构
  - 剑指offer
tags:
  - 
---
> 前面那个CMU硕士100题大概知道了大致的算法和套路，目前还没时间去完善，下面的这个剑指offer我打算每道题都认真总结一下。。

题目链接：[《剑指 Offer（第 2 版）》 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problemset/lcof/)

这里为了避免一页太长，所以就分为多个文件

## 03.数组中重复的数字

[剑指 Offer 03. 数组中重复的数字 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

![image-20210329090222691](https://img.xiaoyou66.com/2021/03/29/d9c9845db3283.png)

有三个解法，第一个就是简单的，我们map来暂存位置信息

```go
func findRepeatNumber1(nums []int) int {
   // 直接使用map
   count:=make(map[int]int)
   for _,v:=range nums{
      if _,ok:=count[v];ok {
         return v
      } else {
         count[v] = 1
      }
   }
   return -1
}
```

解法二，我们可以使用排序，如果相邻位置相同，那么我们就知道是否重复了

```go
func findRepeatNumber2(nums []int) int {
   sort.Ints(nums)
   for k:=range nums{
      if nums[k]==nums[k+1] {
         return nums[k]
      }
   }
   return -1
}
```

最后一个就是使用原地置换方法，这个

```go
func findRepeatNumber(nums []int) int {
   // 特殊判断,这里我们要保证满足条件
   if nums == nil || len(nums) == 0 {
      return -1
   }
   for _, num := range nums {
      if num < 0 || num > len(nums)-1 {
         return -1
      }
   }
   // 遍历数组
   for i := 0; i < len(nums); i++ {
      if i != nums[i] {
         if nums[i] == nums[nums[i]] {
            return nums[i]
         }
         // 交换这两个元素的位置，这个地方是关键，我们可以这样理解，就是如果数组里面有重复的元素
         // 那么nums[i]就必然会有多个相同的值，这里我们交换是为了判断
         nums[i], nums[nums[i]] = nums[nums[i]], nums[i]
      }
   }
   return -1
}
```

## 04.二维数组中的查找

[剑指 Offer 04. 二维数组中的查找 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

![image-20210329112127941](https://img.xiaoyou66.com/2021/03/29/719962fdaba60.png)

这题可以巧妙的看成树的查找

![test](https://img.xiaoyou66.com/2021/03/29/2a094b5ba9863.gif)

实际代码如下：

```go
func findNumberIn2DArray(matrix [][]int, target int) bool {
	// 简单过滤特殊情况
	if len(matrix)==0 || len(matrix[0])==0 {
		return false
	}
	n:=len(matrix[0])
	// i和j分别表示两个下标
	i:=len(matrix)-1;j:=0
	// for循环遍历
	for	i>=0 && j<n{
		// 判断当前这个点是否大于目标值，如果大于我们就需要缩小i
		if matrix[i][j] > target {
			i--
		} else if matrix[i][j] == target{
			return true
		} else {
			// 否则我们就需要增加j的值
			j++
		}
	}
	return false
}
```

## 05.替换空格

![image-20210329114101647](https://img.xiaoyou66.com/2021/03/29/fe721e3dd611c.png)

解法一：使用go的标准库

```go
func replaceSpace(s string) string {
	return strings.ReplaceAll(s," ","%20")
}
```

解法二：直接遍历替换

```go
func replaceSpace(s string) string {
   // 遍历所有字符串
   for i:=0;i<len(s);i++{
      // 如果字符串为空，那么我们就进行替换
      if string(s[i]) ==" " {
         // 我们简单对字符串进行切片拼接
         s=s[:i]+"%20"+s[i+1:]
         //
         i+=2
      }
   }
   return s
}
```

## 06.从尾到头打印链表

[剑指 Offer 06. 从尾到头打印链表 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

![image-20210329214000253](https://img.xiaoyou66.com/2021/03/29/8dc0fb1d87d54.png)

解法一：使用递归（注意这个顺序很重要，我们需要先进度递归，然后再放值，如果反了的话就是顺序遍历了）

```go
func reversePrint(head *ListNode) []int {
   data:=new([]int)
   reverse(data,head)
   return *data
}
// 使用辅助函数进行递归
func reverse(data *[]int,head *ListNode) {
   // 当头部为空时直接返回即可
   if head==nil {
      return
   }
   // 这里就是关键了，因为我们是需要反过来遍历的
   // 所以其实我们这里就是先递归到链表终点
   reverse(data,head.Next)
   // 然后我们再把当前值放入数组中
   *data=append(*data,head.Val)
}
```

解法二： 使用栈

思路就是把数据压入栈中，然后我们不断从栈顶弹出数据

```go
func reversePrint(head *ListNode) []int {
   // 新建一个栈
   stack:=Stack{}
   // 遍历这个链表，把数据压入栈中
   for head!=nil {
      stack.Push(head.Val)
      head=head.Next
   }
   // 遍历栈，把所有的数据弹出，并放入数组
   data:=make([]int, len(stack.data))
   i:=0
   for !stack.Empty() {
       data[i] = stack.Pop()
       i++
   }
   // 返回数据
   return data
}
type Stack struct {
   i   int
   data []int
}
func (s *Stack) Push(k int)  {
   s.data = append(s.data, k)
   s.i = len(s.data)
}
func (s *Stack) Pop() (x int){
   x = s.data[s.i-1]
   s.i--
   return
}
func (s *Stack) Empty() bool {
   return s.i <= 0
}
```

当然，可以使用go的容器类，下面这个就简化了好多

```go
func reversePrint(head *ListNode) []int {
   // 新建一个栈
   stack:=list.New()
   // 遍历这个链表，把数据压入栈中
   for head!=nil {
      stack.PushFront(head.Val)
      head=head.Next
   }
   // 遍历栈，把所有的数据弹出，并放入数组
   var data []int
   for e := stack.Front(); e != nil; e = e.Next() {
      data = append(data, e.Value.(int))
   }
   // 返回数据
   return data
}
```

