---
title: 11-20
date: 2021-03-29 08:56:23
permalink: /pages/63d428/
categories:
  - 算法和数据结构
  - 剑指offer
tags:
  - 
---

## 11.旋转数组最小的数字（看）

[剑指 Offer 11. 旋转数组的最小数字 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)

![image-20210330153515237](https://img.xiaoyou66.com/2021/03/30/557c257dfce07.png)

### 解法一 二分查找

这题目主要还是考理解，下面简单介绍一下原理，旋转数组如下图所示，我们可以把旋转数组简单的分为左排序数组和右排序数组，我们要找的最小值其实就是右排序数组的第一个，也就是旋转点

![Picture1.png](https://img.xiaoyou66.com/2021/03/30/69172da4519bc.png)

那么我们怎么找这个点呢？首先找中间值，然后进行比较，我们可以得出下面这样的结论（可以自己画图证明）

![image-20210330161401610](https://img.xiaoyou66.com/2021/03/30/bb89c8c643ea4.png)

然后就是为什么  j =j  - 1 是正确的（缩小区间安全性），证明如下

![image-20210330161622781](https://img.xiaoyou66.com/2021/03/30/7aa07d99be711.png)

当然，为了方便，我们可以直接把这个结论背下来就行了~

```go
func minArray(numbers []int) int {
   // 获取high和low两个指针
   low := 0
   high := len(numbers) - 1
   // 当low等于high时，我们退出循环，并且返回low指针
   // 注意推荐使用这种解法
   for low < high {
      // 尽量不要使用 (high+low)/2
      // 下面这种方法可以避免溢出的问题
      mid := low + (high - low) / 2
      // 当mid小于high时，旋转点一定会在 [low,mid] 这个区间内（关键）
      if numbers[mid] < numbers[high] {
         high = mid
      } else if numbers[mid] > numbers[high] {
          // 当mid大于high 时，旋转点一定在 [mid+1,high]区间内(关键)
         low = mid + 1
      } else {
         // 如果发现相等，那么缩小high指针
         high--
      }
   }
   // 最后我们的low即为计算结果
   return numbers[low]
}
```

## 12.矩阵中的路径（看）

[剑指 Offer 12. 矩阵中的路径 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

![image-20210330162205754](https://img.xiaoyou66.com/2021/03/30/47cf6ab12a38e.png)

### 解法一 使用DFS加回溯

这题我差点做对了，唉~我没有考虑到路径走过后不能再走一遍，而且还巨傻不用递归，而是一个一个遍历，看了别人的答案后恍然大悟

```go
func exist(board [][]byte, word string) bool {
   if len(board) == 0 || len(board[0]) == 0 || len(word) == 0 {
      return false
   }
   // 判断大小
   m,n:=len(board),len(board[0])
   for i:=0;i<m;i++ {
      for j:=0;j<n;j++ {
         if dfs(board,i,j,0,word) {
            return true
         }
      }
   }
   return false
}

func dfs(board [][]byte,i int,j int,k int,word string) bool  {
   // 判断i，j是否合法
   if i>=len(board) || i<0 || j>=len(board[0]) || j<0 || board[i][j]!=word[k]{
      return false
   }
   // 判断当前位数是否等于字符串的位数
   if k == len(word)-1 {
      return true
   }
   // 我们把当前这位置为0表示我们访问过了
   board[i][j] = 0
   // 然后我们进行上下左右遍历
   res:=dfs(board,i-1,j,k+1,word) || dfs(board,i,j-1,k+1,word) || dfs(board,i+1,j,k+1,word) || dfs(board,i,j+1,k+1,word)
   // 没有的话，我们在进行回溯
   board[i][j] = word[k]
   return res
}
```

## 13.机器人运动范围

[剑指 Offer 13. 机器人的运动范围 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

![image-20210330194801322](https://img.xiaoyou66.com/2021/03/30/b5d8ffa146350.png)

唉，我以为我会做，然而还是不行。。看来自己还得多学习学习。。。先说一下数位之和的计算

可以使用循环求和的方法

```
int sums(int x){
	int s = 0;
    while(x != 0) {
        s += x % 10;
        x = x / 10;
    }
    return s;
}
```

也可以通过数位和的增量公式

![image-20210330203203947](https://img.xiaoyou66.com/2021/03/30/141d90f24cdf1.png)

此题可以证明机器人只需要向右或者向下移动就可以访问所有的可达解

### 解法一 DFS

```go
// 定义全局变量
var n1, m1, k1 int
var visited [][]bool

func movingCount(m int, n int, k int) int {
   m1 = m
   n1 = n
   k1 = k
   // 初始化访问数组
   visited = make([][]bool, m)
   for i := 0; i < len(visited); i++ {
      visited[i] = make([]bool, n)
   }
   // dfs遍历
   return dfs(0, 0, 0, 0)
}

// si和sj分别表示位数之和
func dfs(i int, j int, si int, sj int) int {
   if i >= m1 || j >= n1 || si+sj > k1 || visited[i][j] {
      return 0
   }
   // 标记为访问状态
   visited[i][j] = true
   // sj1表示往右走
   sj1 := sj + 1
   // sj1表示往下走
   si1 := si + 1
   // 这个是一个增量公式，可以快速计算位数和
   if (j+1)%10 == 0 {
      sj1 = sj - 8
   }
   if (i+1)%10 == 0 {
      si1 = si - 8
   }
   // 然后把所有的情况都加起来就是机器人能到达的范围了
   return 1 + dfs(i, j+1, si, sj1) + dfs(i+1, j, si1, sj)
}
```

